# 正则的扩展

1. 构造函数：
   1. 字符串形式：`new RegExp(str[, flag])`
   2. 正则的形式：`new RegExp(re[, flag])`，若re中已定义了flag，则会被后面的flag替换掉
2. 字符串的方法`match`,`replace`,`split`,`search`，es6在语言内部都会调用形如`RegExp.prototype[Symbol.match]`方法，保证所有和正则相关的方法，都定义在RegExp对象上
   1. `matchAll`方法：返回所有匹配的遍历器，可通过for...of取出
      1. 当匹配结果是一个很大的数组时，可节省资源
      2. 转为数组`[...val]`, `Array.from(val)`
3. 修饰符flag：
   1. `u`修饰符：用于处理大于\uFFFF的字符，会正确处理四个字节的UTF-16编码，当具备该修饰符时，会修改以下行为：
      1. 点字符`.`在加上u修饰符后，可识别大于\uFFFF的编码
      2. Unicode表示法必须加上u修饰符，才能识别大括号的编码，否则会当成数量量词
      3. 量词在加上u修饰符后，能够识别大于\uFFFF的字符
      4. 预定义模式（即各种通配符等等，加上转义标志的）加上u修饰符后，能够识别大于\uFFFF的字符，此种情况可返回字符串的正确长度`str.match(/[\s\S]/gu)`
      5. i修饰符和u修饰符一起使用时，可识别非规范的Unicode码，比如\u004b和\u212a都是大写的K
      6. 非转义字符加上\后，结合u修饰符会报错
   2. `y`修饰符：粘连修饰符，全局匹配，后一次匹配的内容从上一次匹配成功的下个字符开始，但正则的匹配也是从该字符开始（保证每次都从头部匹配），匹配失败返回null
      1. re.lastIndex属性可指定匹配开始的位置，当正则的匹配不在该位置时，返回null
      2. 当使用match方法时，必须配合g修饰符一起使用，才能查找所有符合条件的匹配内容
      3. 应用：确保匹配不会像g修饰符一样漏掉内容
   3. `s`修饰符：使点字符`.`可以匹配任意的单个字符，包括四字节的字符和行终止符（换行000A，回车000D，行分隔符2028，段分隔符2029）
4. 正则实例的属性：
   1. `unicode/sticky/dotAll`：是否设置了u/y/s修饰符
   2. `flags`：返回正则对象的修饰符
5. 断言：
   1. 先行断言`/x(?=y)`：x只有在y前面才匹配
   2. 先行否定断言`/x(?!y)`：x只有不在y前面才匹配
   3. 后行断言`/(?<=y)x`：x只有在y后面才匹配，查找时是先查找是否有x，在查找在y后面的x，执行顺序从右向左，所以会有以下的不同：
      1. 组匹配时，也是从右向左的，比如`/(?<=(\d+)(\d+))$/.exec('1053')`的结果是`["", "1", "053"]`，第一个值是匹配的结果，即在1053后面的内容，后面的值，由于是从右往左执行的，所以第二个组匹配是贪婪模式（第三个值）
      2. 在正则中反斜杠的引用，比如`\1`，必须放在组匹配的前面，才能够匹配到（和正常的相反）
   4. 后行否定断言`/(?<!y)x`：x只有不在y后面才匹配
6. Unicode属性类：`\p{...}`和`\P{...}`（前者的反向匹配），匹配符合Unicode某种属性的所有字符
   1. 其中`...`的内容可为`属性名:属性值`, `属性名`两种形式
   2. 属性多，这种类的表达能力非常强
7. 具名组匹配：`/(?<name>...)/`，为每个组匹配指定别名，防止由于类似`\1`顺序改变而得不到正确的内容
   1. 通过val.groups.name获取匹配的内容
   2. 可通过解构赋值的方式获取匹配的内容：`{ groups: {name} }`
   3. 字符串替换replace方法时，第二个参数可使用`$<name>`的方式引用具名组
   4. replace方法的第二个参数可以是函数，函数内部可以直接对组对象进行解构🍊
   5. 正则表达式内部引用具名组，使用`\k<name>`或`\num`的形式，这两种形式可同时出现
8. 其他：
   1. 正则匹配的索引：通过exec方法的返回值的index获取

```js
// 🍊: replace方法的第二个参数为函数的参数表列
'2015-01-02'.replace(re, (
   matched, // 整个匹配结果 2015-01-02
   capture1, // 第一个组匹配 2015
   capture2, // 第二个组匹配 01
   capture3, // 第三个组匹配 02
   position, // 匹配开始的位置 0
   S, // 原字符串 2015-01-02
   groups // 具名组构成的一个对象 {year, month, day}
 ) => {
 let {day, month, year} = groups;
 return `${day}/${month}/${year}`;
});
```