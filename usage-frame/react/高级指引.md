# 高级指引

## 代码分割

知识点：
- 打包：是一个将文件引入并合并到一个单独文件的过程，最终形成一个bundle。接着在页面引入该bundle，整个应用即可一次性加载
- 打包工具：webpack、rollup、browserify
  - 若使用的是create react app、nextjs、gatsby，则内置了webpack。否则需要自己配置webpack构建打包
- 代码分割：出现场景是避免打包出过大体积的代码包，它是打包工具支持的一项技术，能够创建多个包并在运行时动态加载
- 代码分割的优点：
  - 懒加载当前用户所需的内容，显著提高应用性能
  - 避免加载用户永不需要的代码，并在初始加载的时候减少所需加载的代码量
- 代码分割的方式：
  - 使用`import()`函数：无webpack需要配置，若使用了babel需要导入`@babel/plugin-syntax-dynamic-import`插件
  - 使用`React.lazy`函数：像渲染常规组件一样处理动态引入的组件，接受一个返回import()函数的回调函数作为参数；应该在`Suspense`组件中渲染lazy组件，这样可以在等待加载lazy时进行降级（例如使用骨架屏、loading等）；该函数仅支持默认导出（即仅会导出export default的内容），若想支持命名导出（即export）的内容，需要引入中间模块，然后中间模块默认导出引入的具名导出
  - 在路由上进行代码分割
- `Suspense`组件：可以嵌套在懒加载组件上面的任意层级上，同时可以包含多个懒加载组件
- 引入异常捕获边界组件去处理模块加载失败，以显示良好的用户体验并管理恢复事宜

<!-- tabs:start -->
<!-- tabs:import()语法 -->
```js
// 类似promise
import('./my-comp').then(mycomp => {
  console.log(mycomp.getName())
})
```
<!-- tab:React.lazy -->
```js
import React, { Suspense } from 'react'
import Tabs from './tabs'
import MyErrorBoundary from './my-error-boundary'

const OtherComp = React.lazy(() => import('./other-comp'))
const OtherComp2 = React.lazy(() => import('./other-comp2'))

function MyComp () {
  const [tab, setTab] = React.useState('photos')

  function handleTabSelect(tab) {
    // 1. 为了避免这种情况，而是仍然展示切换tab之前的组件，需要在切换函数里面使用startTransition函数
    startTransition(() => {
      setTab(tab)
    })
  }

  return (
    <div>
    // 嵌套一个错误处理组件，用于处理模块加载失败的情况
      <MyErrorBoundary>
        <Tabs onTabSelect={handleTabSelect}/>
        <Suspense fallback={<div>loading</div>}>
          // 懒加载组件需要在Suspense内部
          <OtherComp/>
          // Suspense可以包裹多个懒加载组件
          <OtherComp2/>

          // 当切换tab时，会展示另一个组件，而当另一个组件未准备好(即加载完成时)，会展示fallback的内容
          // 1. 为了避免这种情况，而是仍然展示切换tab之前的组件，需要在切换函数里面使用startTransition函数
          { tab === 'photos' ? <OtherComp/> : </OtherComp2/> }
        </Suspense>
      </MyErrorBoundary>
    </div>
  )
}
```

<!-- tab:基于路由的代码分割 -->
```js
import React, { Suspense, lazy } from 'react'
import { BrowserRouer as Router, Routes, Route } from 'react-router-dom'

const Home = lazy(() => import('./home'))
const About = lazy(() => import('./about'))

const App = () => (
  <Router>
    <Suspense fallback={<div>loading</div>}>
      <Routes>
        <Route path="/" element={<Home/>}/>
        <Routes path="about" element={<About/>}/>
      </Routes>
    </Suspense>
  </Router>
)
```

<!-- tab:命名导出 -->
```js
// 使用中间模块导出具名导出
// my.js
export const my = () => <div/>

// middle.js
export { my as default } from './my.js'

// 引入
import React, {lazy} from 'react'
const MyComp = lazy(() => import('./middle.js'))
```
<!-- tabs:end -->


## Context

知识点：
- Context：提供了一个无需为每层组件手动添加props，就能在组件树间进行数据传递的方法
  - 设计的目的是共享一些对于整个组件树而言全局的数据，比如用户信息、主题、语言等

<!-- tabs:start -->
<!-- tab:1 -->
```js
// 创建一个Context对象，当React渲染了订阅了这个Context对象的组件，这个组件会从组件树中离自身最近的那个匹配的Provider读取当前的context的值
// 参数是默认值，仅在未匹配到Provider时才会生效，若value的值是undefined，默认值同样不生效
const ThemeContext = React.createContext('light')
// 打开react devtools时，展示的节点名称ThemeContext => MyThemeContext
ThemeContext.displayName = 'MyThemeContext'

class App extends React.Component {
  render () {
    // Provider接收一个value属性，传递给消费组件
    // 一个Provider可以和多个消费组件有对应的关系
    // 多个Provider可以嵌套使用，里面的会覆盖外面的
    // 当传递对象给value时，可能会导致一些问题，除非是将对象设置到state中，然后将state的该对象传给value
    <ThemeContext.Provider value="dark">
      <Toolbar/>
    </ThemeContext.Provider>
  }
}

function Toolbar () {
  return (
    <div>
      <ThemeButton/>
    </div>
  )
}

class ThemeButton extends React.Component {
  // 对于启用了public class fields，可以使用类属性
  // 该属性，可以赋值为由React.createContext()创建的Context对象
  // 定义了该属性之后，可以在任意生命周期和render中使用this.context获取最近的Context的值
  static contextType = ThemeContext

  render () {
    return (
      <ThemeContext.Consumer>
        // 接收当前context的值，返回一个react节点，多个context的值，则参数为对象解构的方式
        {
          theme => <Button theme={theme}/>
        }
      </ThemeContext.Consumer>
    )
  }
}
// 未启用public class fields，可以使用：
ThemeButton.contextType = ThemeContext
```

<!-- tabs:end -->