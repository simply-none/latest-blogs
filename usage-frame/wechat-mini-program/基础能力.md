# 基础能力

## 模块化

**require(module, callback, err)**

定义：引入模块，返回模块通过module.exports或exports暴露的接口
- 其中module表示当前模块对象，其有一个属性exports，表示模块向外暴露的对象，使用require引用该模块时可以获取到
- exports表示module.exports的一个引用

```js
// 在同一个包内调用
// 第一个参数path：表示引入模块文件相对于当前文件的相对路径、npm模块名、npm模块路径，默认不支持绝对路径，但可通过配置resolveAlias自定义路径映射
// commom代表common.js导出的module.exports对象
const common = require('common.js')
Page({
  helloJade () {
    // 相当于调用module.exports.sayHello方法
    common.sayHello('Jade')
  }
})

// 跨分包异步调用（不在同一个包内）
let common
// 第一个参数为path
// 第二个参数是异步加载成功的回调函数callback，该callback的参数是成功加载的模块对象
// 第三个参数是异步加载失败的回调函数error，该error的参数是包含错误信息和模块名的对象
require('../packageA/common.js', mod => {
  common = mod
}, ({ errMsg, mod }) => {
  console.log(`path: ${mod}, ${errMsg}`)
})

Page({
  helloJade () {
    common && common.sayHello('Jade')
  }
})

// 以promise形式链式调用
require.async('../packageA/common.js').then(mod => {
  console.log(mod)
}).catch(({ errMsg, mod }) => {
  console.log(`path: ${mod}, ${errMsg}`)
})
```

**requirePlugin(module)**：
- 语法和require类似，表示引入一个插件，返回插件通过main暴露的接口
- 第一个参数module，字符串类型，表示需要引入的插件的alias，也可以是插件的AppID

**requireMiniProgram()**:
- 插件引入 当前使用该插件的小程序，返回小程序通过插件配置中export暴露的接口，无参

## 分包

场景：
- 某些情况下，开发者需要将小程序划分成不同的子包，在构建时打包成不同的分包，用户在使用时按需进行加载

分包小程序的构成：
1. 主包：放置默认启动页面/tabbar页面、分包用到的公共资源（图片、js）等，只有一个，即pages页面的内容
2. 分包：根据开发者配置（功能模块）划分的，可以有多个，所有分包总计不能超过20MB，单个分包/主包不能超过2MB。分包有助于优化首次启动的下载时间，以及协同开发时的解耦协作
   - 声明subpackages后，将按照该字段配置的路径进行打包，路径外的目录将打进主包中
   - subpackage的根目录不能是其他subpackage的子目录

其他知识点：
- 小程序启动时，默认会下载主包并启动主包内页面，当用户进入分包内页面时，客户端会把对应的分包下载，下载完成后再展示内容

使用分包：通过在app.json中配置`subpackages`或`subPackages`字段生命项目分包结构`

分包预下载：
- 在进入小程序某个页面时，由框架自动预下载可能需要的分包，提升进入后续分包页面时的启动速度，对于独立分包来说，可以预下载主包
- 预下载只支持通过配置`preloadRule`字段的方式使用，不支持调用API
- vConsole中有preloadSubpackages开头的日志信息验证预下载的情况
- 同一个分包的页面总计的预下载限额为2MB，限额会在工具中打包时校验，比如一个分包中预下载页面有A、B，A预下载大小为0.5MB，则B的预下载大小只有1.5MB

```js
// 小程序结构
├── app.js
├── app.json
├── app.wxss
├── packageA
│   └── pages
│       ├── cat
│       └── dog
├── packageB
│   └── pages
│       ├── apple
│       └── banana
├── pages
│   ├── index
│   └── logs
└── utils

// 分包配置：app.json
{
  "pages": [
    "pages/index"
  ]
  "subPackages": [
    {
      // 分包根目录
      "root": "packageA",
      // 分包别名，可用于预下载时
      "name": "packA",
      // 分包页面路径，相对于分包根目录
      "pages": [
        "index",
        // 完整路径是：packageA/pages/xxx
        "pages/cat",
        "pages/dog"
      ],
      // 是否是独立分包：为true时表示是独立分包
      "independent": false
    },
    {
      "root": "packageB",
      "pages": ["index"]
    },
    {
      "root": "packageC",
      "name": "packC",
      "pages": ["index"],
      "independent": true
    }
  ],
  "preloadRule": {
    // 其中对象的key表示页面路径，value表示页面的预下载配置
    "pages/index": {
      // network表示仅在指定网络预下载，有all、wifi
      "network": "all",
      // 进入预下载分包的root或name，主包为__APP__
      "packages": ["packageA"]
    },
    "packageA/index": {
      "packages": ["packA", "packageB"]
    },
    "packageC/index": {
      "packages": ["__APP__"]
    }
  }
}
```

分包的引用规则：
- packageA的分包无法require packageB的js文件、无法import packageB的template、无法使用packageB的资源，但是可以require packageA和主包的js文件、可以import packageA和主包的template、可以使用packageA和主包的资源

版本兼容性：会由微信后台编译来处理旧版本客户端的兼容，后台会编译2份代码包，一份是分包后代码，一份是整包的兼容代码，新客户端会用分包代码，旧客户端用整包代码

独立分包：
- 是小程序中一种特殊类型的分包，普通分包的限制条件对独立分包依然有效，可独立于主包和其他分包单独运行
- 从独立分包页面进入小程序不需要下载主包，只有用户进入普通分包或主包页面时，主包才会被下载
- 开发者可将某些具有一定功能独立性的页面配置到独立分包中，这将可以提升分包页面的启动速度
- 一个小程序中可以有多个独立分包
- 独立分包中不能依赖于主包和其他分包的内容，包括js、template、wxss、custom component、plugin（使用分包异步化时，js、custom component、plugin不受这限制）
- 主包的app.wxss对独立分包无效
- `App`只能在主包中定义，独立分包中不能定义App，会造成无法预期的行为
  - 独立分包运行时，`App`不一定被注册，所以`getApp()`不一定可以获取App对象
  - 当从独立分包页面进入小程序时，主包不存在，App也不存在，此时调用getApp获取到的是undefined。只有从其他页面进入时，主包才会下载，App才会被注册，由于这个限制，开发者无法通过App对象实现独立分包与其他页面的全局变量共享
  - 当从其他页面跳转到独立分包页面时，由于主包已经存在，此时可以获取到App对象
  - 为了实现独立分包的全局变量共享，支持`allowDefault`参数，在App未定义时返回一个默认实现值，在主包加载后，该值会被覆盖合并到真正的App对象中
- 独立分包中暂不支持使用插件
- 在低于6.7.2版本的微信中，独立分包视为普通分包处理，在兼容模式下，主包的app.wxss可能会对独立分包页面产生影响，避免独立分包使用主包样式

```js
// 独立分包
const app = getApp({allowDefault: true}) // {}
app.data = { a: 456 }
app.global = {}

// app.js
// { data: {a: 456, b: 123 }, global: {}, other: 'hello' }
App({
  data: { b: 123},
  other: 'hello'
})
```

使用独立分包时，App的生命周期：
- 从独立分包启动小程序时，主包的App的onLaunch和首次onShow会从独立分包页面首次进入主包/其他页面时调用
- 由于独立分包中无法定义App，小程序的生命周期的监听可以使用`wx.onAppShow`, `wx.onAppHide`完成，其他事件的监听可以用`wx.onError`, `wx.onPageNotFound`监听

分包异步化：
- 小程序中，不同的分包对应不同的下载单元，除了非独立分包可以依赖主包外，其他分包不能互相使用自定义组件/require，分包异步化就是打破这一限制，允许通过特定的配置和接口，使部分跨分包内容可以等待下载后异步使用
- 跨分包自定义组件的引用：一个分包中使用了其他分包的自定义组件时，先用占位组件替代，分包下载后再替换回来，可以使用`wx.onLazyLoadError`监听加载事件
- 跨分包js引用：一个分包引用了其他分包的代码时，为了不让下载阻塞代码运行，需要异步获取引用的结果

```js
// 跨分包引用自定义组件，某分包的json文件
{
  "usingComponents": {
    "button": "../packageA/components/button",
    "list": "../packageB/components/full-list",
    "simple-list": "./components/simple-list"
  },
  "componentPlaceholder": {
    "button": "view",
    "list": "simple-list"
  }
}

// 跨分包js代码引用，插件调用则将require换成requirePlugin即可
// 回调函数风格
require('../packageA/utils.js', utils => {
  console.log(utils.whoami)
}, ({mod, errMsg}) => {
  console.error(`path: ${mod}, ${errMsg}`)
})
// promise风格
require.async('../packageA/utils.js').then(pkg => {
  pkg.getPackageName()
}).catch(({mod, errMsg}) => {
  console.error(`path: ${mod}, ${errMsg}`)
})

```

## 代码注入

场景：在小程序启动的过程中，主要的耗时环节有代码包的下载、代码注入。其中注入代码量的大小和内容占用与注入的耗时正相关。利用按需注入和用时注入的特性，可以优化代码注入环境的耗时和内存占用。

**按需注入**：

场景：通常情况下，小程序启动时，启动页依赖的所有代码包（主包、分包、插件包、扩展库等）的所有js代码会全部合并注入，包括其他未访问到的页面和未用到的组件，同时所有页面和组件的js代码会立刻执行，这会造成很多没使用的代码在小程序运行环境中注入执行，影响耗时和内存占用

开启按需注入：通过在app.json中配置一级字段`"lazyCodeLoading": "requiredComponents"`，有选择的注入必要的代码，降低启动耗时和运行内存

注意：
- 启用按需注入后，仅注入当前页使用的内容，其他未使用的内容不会被加载和初始化，这时需要确认小程序的表现是否正常
- 启用按需注入后，页面json配置的所有组件和app.json中usingComponents配置的全局组件，都会是为页面的依赖并进行注入加载，这可能会影响按需注入的效果。建议移除未使用的组件生命，避免在全局声明使用率低的组件。
- 插件包和扩展库不支持按需注入，若需实现插件按需加载，将该插件放在一个分包中，通过分包异步化形式异步引入

**用时注入**：

定义：在开启按需注入的前提下，用时注入可以指定一部分组件不在小程序启动时注入，而在真正渲染时进行注入

使用：指定按需注入后，给某组件配置占位组件，某组件就会自动被视为用时注入组件，即：
- 每个页面内，第一次渲染该组件前，该组件不会被注入
- 每个页面内，第一次渲染该组件时，该组件会被渲染成其占位组件，占位组件汇总渲染流程结束后开始注入
- 注入结束后，占位组件被替换回对应的组件


## 存储

定义：每个小程序都有自己的本地缓存，可以通过storage进行增删改查

隔离策略：
- 同一个微信用户，同一个小程序的storage上限为10MB
- storage以用户为维度，不同用户数据、不同小程序数据无法相互调取
- 同一小程序使用不同插件，这些不同的插件之间、插件和小程序之间的storage无法相互调取
- 不同小程序使用同一插件，这个插件的storage不互通

清理策略：本地缓存的清理时机和代码包一样，只有在代码包被清理时storage才会被清理

用法：
- `wx.setStorage(obj)`：将数据存在指定的key中，会覆盖原有key的内容，若非用户主动删除或因存储原因被系统删除，该数据一直可用。单个key上限1MB（开启加密后上限0.7MB），所有key上限为10MB（开启加密后上限为7.1MB），支持promise形式的回调，obj的参数有：
  - key：键名
  - data：键值，支持原生类型、Date、能被JSON.stringify序列化的对象
  - encrypt：是否开启加密存储，只有异步的接口支持开启，开启后，接口回调耗时增加，同时setStorage和getStorage同时需要设置该属性，且加密后数据比原始数据膨大1.4倍
  - success/fail/complete：接口调用成功、失败、结束时的回调
- `wx.setStorageSync(key, data)`：同步存储，只应用于数据的持久化存储，太多会影响启动耗时
- `wx.getStorage(obj)`：obj参数比setStorage少了一个data属性，支持promise形式的回调，其中：
  - success：接口返回res，使用res.data获取该key的值
- `wx.getStorageSync(key)`；同步获取缓存
- `wx.removeStorage(obj)`：移除指定key的缓存，参数比setStorage少了一个data、encrypt属性，支持promise形式的回调
- `wx.removeStorageSync(key)`：同步移除缓存，支持promise形式的回调
- `wx.clearStorage(obj)`：清理本地所有缓存，参数obj只有success、fail、complete三个函数属性，支持promise形式的回调
- `wx.clearStorageSync()`：同步清理所有缓存，无参，支持promise形式的回调

```js
// 设置缓存
wx.setStorage({
  key: 'user-info',
  value: data,
  // 同时开启
  encrypt: true,
  success () {
    wx.getStorage({
      key: 'user-info',
      // 同时开启
      encrypt: true,
      success (res) {
        console.log(res.data)
      }
    })
  }
})

// 同步存储
try {
  wx.setStorageSync('user-info', data)
} catch (e) {
  console.log(e)
}

// 获取缓存
wx.getStorage({
  key: 'user-info',
  encrypt: true,
  success (res) {
    console.log(res.data)
  }
})

wx.getStorageSync('user-info')

// 清除key为user-info的缓存
wx.removeStorage({
  key: 'user-info',
  success () {}
})

wx.removeStorageSync('user-info')

// 清空缓存
wx.clearStorage({
  success () {}
})

wx.clearStorageSync()
```

## 文件系统

定义：
- 文件系统是小程序提供的一套以*小程序和用户维度*隔离的存储以及一套相应的管理接口

文件分类：
- 代码包文件：指的是项目源代码目录中的文件，由于代码包大小的限制，适用于放置首次加载时需要的文件，访问代码包文件只能以绝对路径方式引入，从项目根目录开始，比如（`/images/xxx.png`或`images/xxx.png`）
- 本地文件：指的是小程序被用户添加到手机后，会有一块独立的文件存储区域，以用户和小程序的维度隔离。通过调用接口本地产生，或是网络下载保存到本地的文件，文件路径均为`{{wxfile/http://path}`的格式，其中http是开发者工具上的，wxfile是客户端上的。本地文件分为：
  - 本地临时文件：临时产生，随时会被回收的文件，不能直接写入内容，仅在当前生命周期内保证是有效的，若想保证以后优先，可使用`saveFile`、`copyFile`等接口将其转成下面两者文件形式。运行时最多存储4GB，运行结束后超过2GB的部分会按文件维度从时间远近被清理。所有小程序占用不能超过6GB，超过则按小程序维度进行清理。在下载临时文件时，可先使用`access`检查该文件是否存在，减少重复下载。
  - 本地缓存文件：通过接口方式`saveFile()`将本地临时文件缓存后的文件，不能自定义存放的目录和名称，和本地用户文件一起最多可存放200MB，仅在代码包清理时才被清理
  - 本地用户文件：比本地缓存文件功能更完整，通过接口方式（特定API）将本地临时文件缓存后的文件，能自定义存放的子目录和名称，有完全的读写权限，可通过`wx.env.USER_DATA_PATH`获取存放目录根路径，和本地缓存文件一起最多可存放200MB，仅在代码包清理时才被清理


使用：通过`fs = wx.getFileSystemManager()`获取全局唯一的文件系统管理器，所有的文件操作都可以通过对象fs进行调用

api使用：

<!-- tabs:start -->
<!-- tab:常用api -->
```js
const fs = wx.getFileSystemManager()
// 注意，下列的接口，若后缀带Sync，则为同步接口，否则是异步的

// 保存文件到系统磁盘（PC）
wx.saveFileToDisk({
  filePath: '',
  success/fail/complete() {}
})

// 新开页面打开文档
wx.openDocument({
  filePath: '',
  // 是否显示右上角菜单
  showMenu: boolean,
  // doc,docx,xls,xlsx,ppt,pptx,pdf
  fileType: '',
  success/fail/complete(){}
})

// 判断文件/目录是否存在
fs.access({
  // 是否存在的本地文件/目录路径
  path: '',
  success/fail/complete(res) {}
})
// 文件存在时，会返回undefined，否则会报错，应该使用try-catch或其他错误处理函数包裹
try {
  fs.accessSync(path)
} catch (e) {
  console.log(e)
}

// 创建目录
fs.mkdir({
  dirPath: '',
  // 是否递归该目录的上级目录后在创建目录，上级目录不存在时，会创建上级目录
  recursive: true,
  success/fail/complete() {}
})

try {
  fs.mkdir(dirPath, recursive)
} catch (e) {
  console.log(e)
}

// 删除目录
fs.rmdir({
  dirPath: '',
  recursive: true,
  success/fail/complete() {}
})

const res = fs.rmdirSync(dirpath, recursive)

// 打开、关闭文件
fs.open({
  filePath: '',
  // 文件系统标志，有r(默认，打开文件读取，不存在，则会发生异常)、r+（打开文件读取和写入，不存在，则会发生异常）、w（打开文件写入，不存在则创建）、w+（打开文件读取和写入，不存在则创建）、a（打开文件追加，不存在则创建）、a+(打开文件用于读取和追加，不存在则创建)、as/as+(效果同a/a+，同步模式，不存在则创建)
  flag: 'a+',
  // 参数res的属性有fd：文件描述符
  success (res) {
    fs.close({
      // 需要被关闭的文件描述符，通过open/openSync函数获取
      fd: res.fd,
      success/fail/complete() {}
    })
  },
  fail/complete() {}
})

const fd = fs.openSync({
  filePath: '',
  flag: 'a+'
})

fs.closeSync({
  fd: fd
})

// 读取文件
fs.read({
  fd: '',
  // 数据写入的缓冲区
  arrayBuffer: arrayBuffer,
  // 缓冲区写入的偏移量
  offset: number,
  // 从文件中读取的字节数
  length: number,
  // 从文件中读取的起始位置
  position: number,
  success (res) {
    const { bytesRead, arrayBuffer } = res
  },
  fail/complete() {}
})

res = fs.readSync({
  fd: '',
  arrayBuffer: arrayBuffer,
  offset/length/position
})

// 读取本地文件内容
fs.readFile({
  filePath: '',
  encoding: '',
  position/length,
  success (res) {
    console.log(res.data)
  },
  fail/complete() {}
})

try {
  const res = fs.readFileSync(filePath, encoding, position, length)
} catch (e) {
  console.log(e)
}

// 读取目录内文件列表
fs.readdir({
  dirPath: '',
  success (res) {
    console.log(res.files)
  },
  fail/complete() {}
})

try {
  const res = fs.readdirSync(dirpath)
} catch (e) {
  console.log(e)
}

// 写入文件
fs.write({
  fd: '',
  data: string/arrayBuffer,
  offset/length/position,
  encoding: '',
  success (res) {
    const { bytesWritten } = res
  },
  fail/complete () {}
})

const res = fs.writeSync({
  fd: '',
  data,
  offset/length/position,
  encoding
})

// 写入本地文件
fs.writeFile({
  filePath: '',
  data: string/arrayBuffer,
  encoding: '',
  success/fail/complete () {}
})

const res = fs.writeFileSync(filePath, data, encoding)

// 复制文件
fs.copyFile({
  srcPath: '',
  // 目标文件路径
  destPath: '',
  success/fail/complete() {}
})

try {
  fs.copyFileSync(srcPath, destPath)
} catch (e) {
  console.log(e)
}

// 删除保存的本地缓存文件
fs.removeSavedFile({
  filePath: '',
  success/fail/complete() {}
})

// 重命名文件，文件移动
fs.rename({
  oldPath: '',
  newPath: '',
  success/fail/complete() {}
})

try {
  const res = fs.renameSync(oldPath, newPath)
} catch (e) {}

// 在文件结尾追加内容
fs.appendFile({
  filePath: '',
  // 要追加的文本、二进制数据
  data: string/arrayBuffer,
  // 指定写入文件的字符编码，值有uft8（默认）、ascii、base64、ucs2、uth16le
  encoding: string,
  success/fail/complete() {}
})

try {
  fs.appendFileSync(path, data, encoding)
} catch (e) {
  console.log(e)
}

// 保存文件
fs.saveFile({
  tempFilePath: '',
  filePath: '',
  success (res) {
    const { savedFilePath } = res
  },
  fail/complete () {}
})

const savedFilePath = FS.saveFileSync(tempFilePath, filePath)

// 删除文件
fs.unlink({
  filePath: '',
  success/fail/complete() {}
})

const res = fs.unlinkSync(filePath)

// 解压文件
fs.unzip({
  zipFilePath: '',
  targetPath: '',
  success/fail/complete () {}
})

// 获取已保存的本地缓存文件列表
fs.getSavedFileList({
  success (res) {
    const { fileList } = res
    const { filePath, size, createTime } = for(fileList)
  }
})
```

<!-- tab:不常用 -->
```js
// 获取文件状态信息
fs.fstat({
  // 文件描述符，同上
  fd: '',
  success/fail/complete() {}
})

// stats表示文件状态的对象
const stats = fs.fstatSync({fd: fd})
const {
  // 文件类型和存取的权限
 mode: '',
 size: number,
  //  最近一次操作的unix时间
  lastAccessedTime: number,
  lastModifiedTime: number
  // 判断当前文件是否是目录
  isDirectory(),
  // 当前文件是否是普通文件
  isFile()
} = stats

// 获取小程序下的本地临时文件、本地缓存文件的信息
fs.getFileInfo({
  filePath: '',
  success (res) {
    console.log(res.size)
  },
  fail/complete() {}
})
```
<!-- tabs:end -->

## 多线程Worker

场景：一些异步处理的任务，可以放置在Worker中运行，待运行结束后，再把结果返回给小程序主线程。

使用事项：
- Worker运行在一个单独的全局上下文和线程中，不能直接调用主线程的方法
- Worker与主线程之间传输数据，双方使用`Worker.postMessage()`来发送数据，使用`Worker.onMessage()`来接收数据，传输的数据不是直接共享的（内存地址不一样），而是复制后的值传递

**使用流程**：

```js
// 1. 在app.json中配置Worker放置的 目录workers ，目录下的代码将被打包成一个文件
{
  "workers": "workers"
}

// 2. 添加Worker代码文件，添加后目录结构如：
├── app.js
├── app.json
├── project.config.json
└── workers
    ├── request
    │   ├── index.js
    │   └── utils.js
    └── response
        └── index.js

// 3. 编写Worker代码
// 在workers/request/index.js中编写Worker响应代码
const utils = require('./utils')

// 在Worker线程执行上下文中会暴露一个worker对象，直接调用数据发送接收方法即可
worker.onMessage((res) => {
  console.log(res)
})

// 4. 在主线程（即在app.js)中初始化Worker，path是worker入口的绝对路径
const worker = wx.createWorker('workers/request/index.js')

// 5. 主线程向Worker发送信息
worker.postMessage({
  msg: 'hello worker'
})
```

注意事项：
- Worker最大并发是1个，创建下一个前需用`Worker.terminate()`结束当前的Worker
- Worker内代码只能require指定的Worker路径内的文件，无法引用其他路径
- Worker的入口文件由`wx.createWorker()`指定，可动态指定入口文件地址
- Worker内不支持`wx.xx`的api
- Worker之间不支持发送消息
- Worker目录中只能放置js文件，其他文件需在其目录外
- 插件使用worker前需要在plugin.json中放在workers的代码相对路径path


## 自定义tabBar

场景：自定义tabBar可以更加灵活的设置tabBar的样式结构，以满足更多个性化的场景

在自定义tabBar模式下的使用事项：
- 为了低版本兼容和区分哪些页面是tab页，tabBar相关配置项（即tabbar字段）需要完整的声明
- 使用tabBar需要提供一个自定义组件（即与pages同级的目录custom-tab-bar）渲染tabBar，所有tabBar的样式都由该组件渲染，推荐使用fixed在底部的cover-view+cover-image渲染样式，保证其层级相对较高
- 原来的与tabBar样式相关的接口，都将失效，比如`wx.setTabBarItem`
- 每个tabBar页下的自定义tabBar组件实例是不同的，可通过自定义组件下的getTabBar获取当前页面自定义tabBar组件实例
- 若想实现tab选中态，要在当前tab页面下，通过getTabBar接口获取tabbar实例，调用setData更新选中态。

**使用步骤**：

```js
// 1. 在app.json中的tabBar字段指定custom字段，同时其他的配置需要补充完整。且所有tab的页面的json文件都需要声明usingComponents项（即使是空对象），也可以在app.json全局开启
{
  "tabBar": {
    "custom": true,
    "color": "#000000",
    "selectedColor": "#000000",
    "backgroundColor": "#000000",
    "list": [
      {
        // tabBar页面路径，该页面的json需要配置usingComponents字段
        "pagePath": "page/component/index",
        // 该页面下tabBar的展示名称
        "text": "组件"
      },
      {
        // xxx
      }
    ]
  },
  // 也可以在全局配置该字段
  "usingComponents": {}
}

// 2. 添加tabBar代码文件（和普通组件类似），必须是在与pages同级的custom-tab-bar目录下，组件名为index，比如 custom-tab-bar/index.json

// 3. 编写tabBar代码，和组件类似，当切换tab时，在custom-tab-bar/index.js中
Component({
  methods: {
    switchTab(e) {
      const data = e.currentTarget.dataset
      const url = data.path
      // 跳转到该tabBar所在页面
      wx.switchTab({
        url: url || 'page/component/index'
      })
      // 第一次设置该tabBar选中状态，tabBar的唯一标识符，比如id等
      this.setData({
        selected: data.selected
      })
    }
  }
})

// 4. 在tabBar所在页面（比如：page/component/index页面）再次设置选中状态，不然选不中有小bug
// page/component/index.js
Component({
  pageLifeTimes: {
    show() {
      if (typeof this.getTabBar === 'function' && this.getTabBar()) {
        this.getTabBar().setData({
          selected: 1
        })
      }
    }
  }
})
````

## 数据预拉取

场景：预拉取能够在小程序冷启动时通过微信后台提前向第三方服务器拉取业务数据，当代码包加载完成时可以更快渲染页面，减少用户等待时间，提升小程序打开速度

## 黑暗模式DarkMode

https://developers.weixin.qq.com/miniprogram/dev/framework/ability/darkmode.html

## 屏幕适配指南

https://developers.weixin.qq.com/miniprogram/dev/framework/ability/adapt.html