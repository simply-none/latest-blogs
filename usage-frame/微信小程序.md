# 微信小程序

## 自定义组件

> 无特殊说明，下列的组件均指自定义组件

### 创建组件

自定义组件由json、wxml、wxss、js四个文件构成，和page类似。

定义自定义组件，需在其json文件中添加键值`"component": true`，表明其为自定义组件。

在js文件中使用`Component()`函数注册组件，其参数为一个对象，和page类似。

在其他地方使用组件，需在使用该组件的json文件中添加引用声明字段`"usingComponents": { "component-tag-name": "path" }`，全局组件可在`app.json`中一次引用，后续所有地方都可直接引入该组件。

自定义组件和页面所在项目根目录名不能以`"wx-"`开头，否则会报错文档(*存疑，指南-自定义组件-介绍*)

### 组件模板（wxml）

自定义组件的标签名，只能包含小写字母、中划线、下划线，所以引用组件（json声明组件、wxml引用组件）时，应当注意。

### 组件样式（wxss）

**构建样式**时，应该使用class选择器：
1. 不应该使用id（#a）、属性（[a]）、标签选择器，否则无效。
2. 避免使用后代选择器（.a .b），可能会出现非预期效果，且该选择器只能用于view组件与其子组件之间。

**样式的继承**：
1. 继承样式类型（font、color等），会自动从组件外继承
2. 非继承样式类型，不会自动继承，除非更改**组件样式隔离选项**

**组件样式隔离**；
1. 默认情况下，组件的样式只受组件自身wxss影响
2. 当在`app.wxss`或者页面的wxss中使用了标签名以及其他的一些特殊选择器直接指定样式时，会影响到全部组件或者页面内的组件（不推荐）
3. 当指定了样式隔离选项（js或者json中），组件的样式会受到相应的影响：

```js
// 样式隔离选项
Component({
  options: {
    // addGlobalClass：该选项为true等同于styleIsolation：isolated（优先级更高，会覆盖addGlobalClass）
    addGlobalClass: true,

    // isolated：启用样式隔离（默认值），组件的样式只受组件自身wxss影响
    styleIsolation: 'isolated'
    // apply-shared（申请分享样式）：表示页面样式会影响到组件
    styleIsolation: 'apply-shared'
    // shared（分享样式）：表示页面样式会影响组件，组件样式会影响页面和其他设置了apply-shared或shared的组件
    styleIsolation: 'shared'

    // 当Component构造器用于构造页面时，shared为默认值，同时还有下列隔离选项
    // page-isolated：表示页面禁用app.wxss的样式，同时页面样式不会影响到组件
    styleIsolation: 'page-isolated'
    // page-apply-shared：表示页面禁用app.wxss的样式，同时页面样式不会影响到组件，但设为shared的组件会影响页面
    styleIsolation: 'page-apply-shared'
    // page-shared：表示页面禁用app.wxss的样式，同时页面样式会影响到其他设置了apply-shared或shared的组件，也会受其他设为shared的组件样式的影响
    styleIsolation: 'page-shared'
  }
})
```

```json
// 也可以在json中设置样式隔离选项
{
  "styleIsolation": "isolated"
}
```

**`:host`选择器**：组件可以使用`:host`选择器指定所在根节点的默认样式，相当于该组件的全局样式

<!-- tabs:start -->
<!-- tab:组件的结构 -->
```wxml
<!-- 组件的结构 -->
<text class="cus-t">这是一段文本</text>
```

```wxss
/* 指定默认样式 */
:host {
  color: red;
  background-color: yellow;
  border: 1px solid green;
}
```

```wxml
<!-- 引用组件 -->
<custom-com></custom-com>
```

<!-- tab:dom最终解析结果 -->
```wxml
<!-- :host选择器渲染的内容，作用在custom-com上 -->
<custom-com is="component-path">
#shadow-root
  <!-- .cus-t渲染的内容 -->
  <text class="cus-t">这是一段文本</text>
</custom-com>
```
<!-- tabs:end -->

**外部样式类**：

使用场景：组件希望接受外部传过来的样式

用法：在Component中`externalClasses`定义一个接受的外部样式的类是数组

```js
// 定义接受的样式类数组
Component({
  externalClasses: ['red-text', 'large-text']
})
```

```wxml
<!-- 页面或其他组件中使用组件 -->
<custom-com class="red-text"></custom-com>
<custom-com class="large-text"></custom-com>
<!-- 定义多个样式类 -->
<custom-com class="red-text large-text"></custom-com>
```

注意：
1. 同一个节点上使用普通样式类和外部样式类时，没有优先级之分，所以应当避免同时使用具有相同功能的两种样式

**其他方法引用页面、父组件的样式**：

场景：在启用了样式隔离isolated，同时未引入外部样式类的情况下，还想引用父级的类样式

使用：
1. 引用页面的样式类：直接在组件内部使用形如`class="~page-red-text"`的方式，就能在该元素上引入页面的page-red-text样式类
2. 引用父组件的样式：直接在组件内部使用形如`class="^的方式，就能在该元素上引入父组件的parent-red-text"`的方式，就能在该元素上引入父组件的parent-red-text样式类，若想引用祖先组件的样式类，根据层级数来确定`^`的数量，比如祖组件为`^^`，曾祖组件为`^^^`

注意：
1. 若组件是独立通用的组件，优先使用外部样式类的方式

**虚拟化组件节点**：

知识点：
1. 默认情况下，组件本身那个节点（比如custom-com）是一个普通的节点，使用时可以在其上面设置class、style等，如同view组件一样

场景：若自定义组件不希望该节点本身进行设置样式，而是希望内部的第一层节点响应该样式时，可以将该组件节点设置为虚拟节点

使用：在Component中的options选项设置`virtualHost: true`

注意：设置了虚拟节点后，若想使用自定义节点上的style和class，应当将，
1. 在properties中添加style属性，以获取style设置的值
2. 在externalClasses中添加值为class的元素，让组件wxml内部可以使用class值(*未实现，指南-自定义组件-组件模板和样式*)

### Component构造器

知识点：
1. Component构造器可用于定义组件，调用该构造器可以指定组件的属性、数据、方法
2. Component还可用于构造页面，用法和定义组件类似，此时：
   1. 需要在json文件中包含`usingComponents`字段
   2. 组件的属性properties可以用于接收访问页面的参数`page/index?paramA=10`，若properties中声明了paramA，该值会被初始化为10
   3. 页面的生命周期方法（以on开头的）应该写在methods中

```js
// Component构造器
Component({
  // 公有的行为
  behaviors: [],
  // 传入的props或者是页面组件传入的参数
  properties: {},
  // 私有数据
  data: {},
  // 生命周期函数
  lifetimes: {
    // 生命周期函数的值可以是函数，或者是定义的方法名，同时这些函数可以写在和lifetimes同级下
    attached () {},
    moved () {},
    detached: 'detachedM'
  },
  // 生命周期函数的值可以是函数，或者是定义的方法名，同时这些函数可以写在和lifetimes同级下
  // 此处的生命周期函数会被lifttimes下同名函数覆盖
  attached () {},
  // 组件所在页面的生命周期函数
  pageLifetimes: {
    show () {},
    hide () {}
  },
  methods: {
    detachedM () {},
    // 内部方法建议以_开头
    _showDialog () {}
  }
})
```

注意：
1. 使用构造器构造页面的好处是可以使用behaviors提取所有页面公用的代码段（公用的属性、方法、生命周期等）

### 使用插槽

在组件的wxml中使用`slot`标签，承载引用该组件时，插入到该组件内部的内容，和vue类似，其中：
1. 在组件的js文件中，在options字段上添加`multipleSlots: true`，可启用多slot支持，此时slot需要有确定的name属性
2. 在引用该组件时，该组件内部，在元素中添加`slot="slot-name"`可将该代码块插入到对应的slot上

<!-- tabs:start -->
<!-- tab:定义组件 -->
```wxml
<view class="container">
  <slot name="first"></slot>
  <text>内容</text>
  <slot name="last></slot>
</view>
```

```js
Component({
  options: {
    multipleSlots: true
  }
})
```

<!-- tab:使用组件 -->
```json
{
  "usingComponents": {
    "show-content": "./path/path"
  }
}
```

```wxml
<view>
  <show-content>
    <view slot="first">
      <text>这是slot为first的内容</text>
    </view>
    <view slot="last">
      <text>这是slot为last的内容</text>
    </view>
  </show-content>
</view>
```
<!-- tabs:end -->